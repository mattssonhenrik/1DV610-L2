# Naming of identifiers
| Identifiers       | Rules | Reflections |
|------------------------|-------------------------------|---------------------|
| **BrowserDisplayOutput**  | **Class Names**: "Classes and objects should have noun or noun phrase names"". <br> **Add Meaningful Context**: "There are a few names which are meaningful in and of themselves-most are not". <br> **Avoid Disinformation**: "Programmers must avoid leaving false clues that obscure the meaning of code". <br> **Don’t Add Gratuitous Context**: "Add no more context to a name than is neccessary". | **`BrowserDisplayOutput`** Obviously, the browser will be on a display (99/100) and here I might have added unecessary text, a better option might have been BrowserTextOutput or simply BrowserOutput. I like the idea of specifying that this will problably be displayed in a display and that it is output that is being displayed. Although here it does two things which is firstly displaying instructions to the user and as well changing the color when the input is incorrect and back when the input is correct again, so it is in fact doing two things which makes it a little harder to name with precision. I regret starting 3 of my modules/classes with the word browser, many times did I click on the wrong module just because these all started with `browser`. When naming my input modules I activly chose to put input in the end making some class names a bit wonky, like inputRule would easily have been a cleaner option than ruleForInput. With the browser class case I could have gone with OutputBrowser, UXBroswer and InputFromBrowser, or something like that - or even have them named with snake_casing and naming them all with browser_***** which would group them all nicley in the source-list and quickly would the first word be ignored to go to the juicy part after the underscore.
| **getChosenRule**         | **Method Names**: "Methods should have verb or verb phrase names".<br> **Use Intention-Revealing Names**: "The name of a variable, function, or class should answer all the big questions. It should tell you why it exits, what it does, and how it is used".<br> **Don’t Be Cute**: "Choose clarity over entertainment value".<br> **Pick One Word per Concept**: "Pick one word for one abstract concept and stick with it".| **`getChosenRule`** kinda reads out what the function activly does, it very specific and clear. The module/application itself consist mainly of an input element where a user is informed whether the input is correct or not based on the current rule. I think the modules in general are doing quite a good job in centralizing around specific key words such as rule, browser, input, key, validate. |
| **setColor**              | **Method Names**: "Methods should have verb or verb phrase names". <br> **Pick One Word per Concept**: "Pick one word for one abstract concept and stick with it".<br> **Avoid Disinformation**: "Programmers must avoid leaving false clues that obscure the meaning of code".<br> **Don’t Add Gratuitous Context**: "Add no more context to a name than is neccessary". | **`setColor`** is a classic "setter-name", concise and clear, describing exactly what it does. Although here I went a little over board with "Don't Add Gratuitous Context", when looking back on it, WHAT are we changing color on? For me who programmed this it is clear (for now), but for a new developer taking part of the project it is near to impossible to know what we're changing color on without checking the actual method. So we might have kept it a little too short, a little to abstract.|
| **correctInput**          | **Use Intention-Revealing Names**: "The name of a variable, function, or class should answer all the big questions. It should tell you why it exits, what it does, and how it is used". <br> **Add Meaningful Context**: "There are a few names which are meaningful in and of themselves-most are not". **Avoid Disinformation**: Ensure that the name cannot be confused with another concept. | **`correctInput`** when I was programming this felt so right but at a closer contemplation it does not convey that this is a boolean (could for instance be a correct `string`-answer to a question), renaming it to `isInputValid` improves clarity by indicating that it's a check for correctness. Other than that I believe that the (is)correctInput variable name is a short and clear name which explains what it is about without further investigation when you know the context of the application/module. |
| **totalKeysSelected**     | **Use Intention-Revealing Names**: "The name of a variable, function, or class should answer all the big questions. It should tell you why it exits, what it does, and how it is used". <br> **Avoid Encodings**: Avoid adding unnecessary detail like encoding types. <br> **Use Pronounceable Names**: "If you cant't pronounce it, you can't discuss it without sounding like an idiot." | **`totalKeysSelected`** is a name that has been an eyesore for me, it does not feel right but on the paper it should be a word that is decent at minimum. One thing I thought about when reading about is that one should problably avoid words that end and start with s because it is hard to make a distinction of where the word ends and the other word starts when discussing it in real life and not in text, here we got `total` as a indicator letting us know that it is problably keyS and not a single key we are discussing, if we had a better naming which clearly distincs keyS from key we could maybe omit the `totalt` part of the word.
  
<br>
<br> 
  
# Use of Methods
| Methods                  | Rules                                          | Reflecitons                                            |
|------------------------------|---------------------------------------------------------------|--------------------------------------------------------------|
| **`checkValidityOfKey`**         |  **Do One Thing**: "FUNCTIONS SHOULD DO ONE THING. THEY SHOULD DO IT WELL. THEY SHOULD DO IT ONLY".<br> **One Level of Abstraction per Function**: "In order to make sure our functions are doing "one thing," we need to make sure that the statements within our function are all at the same level of abstraction".<br> **Have No Side Effects**: "Side effects are lies. Your function promises to do one thing, but it alsoe does othr *hidden* things." | The function should have been broken into smaller pieces by making it into more functions doing one thing and one thing only, i.e. checking the key towards the current REGEX (according to current rule). The function is also mixing abstraction level by mixing low level and high level abstraction programming, here I should have either chosen to use only function calls or use low level abstraction programming. The naming was bad also since the name indicates that it only check if the key is valid, not that it is going to change the color.
| **`selectedKeyToProcess`**      |  **Do One Thing**: "FUNCTIONS SHOULD DO ONE THING. THEY SHOULD DO IT WELL. THEY SHOULD DO IT ONLY". <br> **Have No Side Effects**: "Side effects are lies. Your function promises to do one thing, but it alsoe does othr *hidden* things." | Again, I break the rule of functions being small and just doing one thing. This function both proccess the key and then dispatching an event, I should have lifted the dispatching of the event and the calling of selectedKeyToProcess() to a high level abstraction function. The event dispatched triggers another event listener which makes you first read from the top, then go to the `selectedKeyToProcess` and then back up to the event listener and then back again to the function `checkValidityOfKey`, not only is this a side effect but an annoying one as well. In the function `selectedKeyToProcess` I even have a line of code which is totally redundant (`this.totaltKeysSelected = event.detail.totalKeysSelected`) which makes the function a little bit misleading for the reader.|
| **`checkRules`**                |  **Descriptive Names**: "Use a naming convention that allows multiple words to be easily read in the function names, and then make use of those multiple words to give the function a name that says what it does".| This function is direct and descriptive, it does not confuse the reader. The function itself got a little long and I was wondering if it could have been a good idea to make this function a high level abstraction function which somehow could have cleared out which rule was in effect and then made function call to the actual function which would be valid with that rule in effect.
| **`storeKeyPress`**             |  **Do One Thing**: "FUNCTIONS SHOULD DO ONE THING. THEY SHOULD DO IT WELL. THEY SHOULD DO IT ONLY". | This function is a mess, I should have handled the "unwanted" scenarios in a seperate function and not in the function where I want to store the key being pressed. Now there is a "positive" part of the function which stores the wanted key presses and a "negative" part of the function which "blocks" the unwanted key presses. Also whilst developing my code I found myself looking for this function in the processInput.js module quite often because we are processing the key press, so therefor I believed the function should have been there and maybe I should have taken the time and effort to refactor it into that part but I did not get around that. |
| **`checkForInvalidKeys`**       |  **Do One Thing**: "FUNCTIONS SHOULD DO ONE THING. THEY SHOULD DO IT WELL. THEY SHOULD DO IT ONLY".<br> **One Level of Abstraction per Function**: "In order to make sure our functions are doing "one thing," we need to make sure that the statements within our function are all at the same level of abstraction". <br> **Have No Side Effects**: "Side effects are lies. Your function promises to do one thing, but it alsoe does othr *hidden* things." <br> **Descriptive Names**: "Use a naming convention that allows multiple words to be easily read in the function names, and then make use of those multiple words to give the function a name that says what it does". | The good thing about this function is that is clearly stating htat it is validating the keys which have been inserted, but its clearly omitting thee fact htat is has a side-effect which is that it is also modifying the color on the input-element when the input-element contains only valid characters. And as with the function `checkValidityOfKey` it is mixing level of abstractions and breaking do one tingwith REGEX-check and dispatching events.| 
